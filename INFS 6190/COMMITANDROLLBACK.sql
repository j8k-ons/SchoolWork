-- COMMIT and ROLLBACK

BEGIN TRANSACTION exampleTransaction; 

-- DML (SET INSERT DELETE)


-- INSERTS
SELECT * FROM VENDOR; 

-- Plain Insert
INSERT INTO VENDOR VALUES (1062, 'MTSU ELECTRONICS UNLIMITED','201 Main Street','Murfreesboro','TN','37132'); 

-- NULL INSERTS
INSERT INTO VENDOR VALUES (1063, 'MTSU ELECTRONICS LIMITED', NULL,NULL,'TN',NULL); 

-- INSERT WITH FIELD/ATTRIBUTE LIST
INSERT INTO VENDOR (VEND_NUM, VEND_NAME) VALUES (1064, 'NASHVILLE SUPPLIES'); 
INSERT INTO VENDOR (VEND_STREET, VEND_CITY, VEND_ZIP, VEND_NAME, VEND_NUM) VALUES ('101 Broad St.', 'M''boro', '37130','Bad Electronics','1065'); 


-- UPDATE (CHANGING VALUES IN AN EXISTING ROW) 

-- IDENTITY COLUMNS FOR SURROGATE KEYS

CREATE TABLE dbo.IDENTITIES(
	assign_num int identity(100,2) primary key, 
	id_num int not null, 
	field_num int not null); 

SELECT * FROM dbo.IDENTITIES; 

-- Because we added identity column you do not provide a value for that column
INSERT INTO dbo.IDENTITIES VALUES (1, 10); 
INSERT INTO dbo.IDENTITIES VALUES (2, 10); 


-- More Updates

SELECT * FROM CUSTOMER; 

ALTER TABLE CUSTOMER 
ADD CUST_TOTAL DECIMAL(10,2); 


-- Using a correlated subquery in the update command
UPDATE CUSTOMER 
SET CUST_TOTAL = (SELECT SUM(INV_TOTAL) FROM INVOICE WHERE CUSTOMER.CUST_CODE = INVOICE.CUST_CODE); 


-- Reference another table without using a subquery 

ALTER TABLE CUSTOMER
ADD CUST_MIN DECIMAL(10,2); 


-- UPDATE FROM clause
UPDATE CUSTOMER
SET CUSTOMER.CUST_MIN = INCOME_MIN
FROM CUSTOMER JOIN INCOME ON CUSTOMER.INCOME_CODE = INCOME.INCOME_CODE; 

ALTER TABLE CUSTOMER
DROP COLUMN CUST_TOTAL; 

-- Synonyms

SELECT * FROM STARTERDB.TECHRESELL.GIFT; 

-- DOES NOT CHECK UNTIL RUNTIME, YOU CAN CREATE SYNONYM FOR THINGS THAT DO NOT EXIST
-- CREATE SYNONYM GIFT FOR STARTERDB.TECHRESELL.GIFT; 
SELECT * FROM GIFT; 
-- Don't use synonyms in production use unless it has been coordinated that noone else is using it. 
DROP SYNONYM GIFT; 


-- EQUI JOIN
SELECT * 
FROM CUSTOMER C JOIN INVOICE I ON C.CUST_CODE = I.CUST_CODE; -- EquiJoin

-- THETA JOIN
SELECT INV_NUM, INV_TOTAL, GIFT_MINQUALIFY, GIFT_MAXQUALIFY, GIFT_NAME 
FROM INVOICE JOIN GIFT ON INV_TOTAL BETWEEN GIFT_MINQUALIFY AND GIFT_MAXQUALIFY
ORDER BY INV_NUM; 


-- How many invoices a customer had during a certain date range by customer? 03/1/2021 - 03/15/2021
-- You have to filter in the FROM clause because filtering using a WHERE clause will cause many of the null values to disappear because they do 

SELECT C.CUST_CODE
	, C.CUST_LNAME
	, COUNT(I.INV_NUM) AS NumINVOICES
FROM CUSTOMER C LEFT JOIN INVOICE I ON C.CUST_CODE = I.CUST_CODE AND CAST(INV_DATE AS DATE) BETWEEN '2022-03-01' AND '2022-03-15' -- Don't do this for all WHERE clauses because it filters in a spot that most people won't see. 
GROUP BY C.CUST_CODE, C.CUST_LNAME
ORDER BY NumINVOICES DESC; 

-- PIVOT and UNPIVOT

SELECT PROD_CATEGORY
	, DATENAME(M, INV_DATE) AS MONTH
	, SUM(LINE_QTY * LINE_PRICE) AS TOTAL
FROM PRODUCT JOIN LINE ON LINE.PROD_NUM = PRODUCT.PROD_NUM 
	JOIN INVOICE I ON LINE.INV_NUM = I.INV_NUM
GROUP BY PROD_CATEGORY, DATENAME(M,INV_DATE); 

-- How to turn this into a PIVOT table? 

/* Every column in the table must be accounted for in a pivot. 
	You have to limit before you do the pivot if you don't want all the columns. 
*/

WITH BASETABLE 
	AS (
		SELECT PROD_CATEGORY
			, DATENAME(M, INV_DATE) AS MONTH
			, LINE_QTY * LINE_PRICE AS SUBTOTAL
		FROM PRODUCT P 
			JOIN LINE L ON P.PROD_NUM = L.PROD_NUM 
			JOIN INVOICE I ON L.INV_NUM = I.INV_NUM
	)
SELECT PROD_CATEGORY, FORMAT(JANUARY, 'C') AS JAN, FORMAT(FEBRUARY, 'C') AS FEB, MAY, AUGUST 
FROM BASETABLE
PIVOT (
	SUM(SUBTOTAL)
	FOR MONTH IN (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER)
	) AS RESULT; 

 -- FLIP PROD_CATEGORY AND MONTHS
	WITH BASETABLE 
	AS (
		SELECT PROD_CATEGORY
			, DATENAME(M, INV_DATE) AS MONTH
			, LINE_QTY * LINE_PRICE AS SUBTOTAL
		FROM PRODUCT P 
			JOIN LINE L ON P.PROD_NUM = L.PROD_NUM 
			JOIN INVOICE I ON L.INV_NUM = I.INV_NUM
	)
SELECT *
FROM BASETABLE
PIVOT (
	SUM(SUBTOTAL)
	FOR PROD_CATEGORY IN (HARDWARE, SOFTWARE)
	) AS RESULT; 


-- What to do if the number of values is variable or massive? 
-- Write a TSQL procedure that runs code to generate those values. 

-- How to save the results of a PIVOT into another table? 

WITH BASETABLE 
	AS (
		SELECT PROD_CATEGORY
			, DATENAME(M, INV_DATE) AS MONTH
			, LINE_QTY * LINE_PRICE AS SUBTOTAL
		FROM PRODUCT P 
			JOIN LINE L ON P.PROD_NUM = L.PROD_NUM 
			JOIN INVOICE I ON L.INV_NUM = I.INV_NUM
	)
SELECT *
INTO PIVOTTABLE
FROM BASETABLE
PIVOT (
	SUM(SUBTOTAL)
	FOR MONTH IN (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER)
	) AS RESULT; 

SELECT * FROM PIVOTTABLE; 


-- UNPIVOT DATA

SELECT PROD_CATEGORY
	, MYMONTH
	, TOTAL
FROM PIVOTTABLE
UNPIVOT (
	TOTAL
	FOR MYMONTH IN (JANUARY, FEBRUARY, MARCH, APRIL, MAY, JUNE, JULY, AUGUST, SEPTEMBER, OCTOBER, NOVEMBER, DECEMBER)
) AS RESULT; 



-- STRING AGGREGATE

SELECT EMP_TITLE
	, EMP_LNAME
FROM EMPLOYEE
ORDER BY EMP_TITLE; 

-- How to show just a list for each row? 

SELECT EMP_TITLE
	, STRING_AGG(CONCAT(EMP_LNAME, ': ', EMP_PHONE), ',    ') WITHIN GROUP (ORDER BY EMP_LNAME) AS 'EMPLOYEES'
FROM EMPLOYEE
GROUP BY EMP_TITLE
ORDER BY EMP_TITLE; 

-- Dynamic Set and Large Sets of PIVOT 

SELECT STRING_AGG(QUOTENAME(VEND_STATE), ', ') WITHIN GROUP (ORDER BY VEND_STATE)
FROM (SELECT DISTINCT VEND_STATE FROM VENDOR) AS SUB; 