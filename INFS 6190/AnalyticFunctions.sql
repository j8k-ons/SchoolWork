-- Analytic Functions
-- Newer series of tools that help solve inline view problems 

-- Subquery version 

SELECT PROD_NUM
	, PROD_NAME
	, PROD_PRICE
	, AVGPRICE
	, P.VEND_ID
FROM PRODUCT P JOIN (SELECT VEND_ID, AVG(PROD_PRICE) AS AVGPRICE
					FROM PRODUCT
					GROUP BY VEND_ID) AS AVGS ON P.VEND_ID = AVGS.VEND_ID -- UNCORRELATED SUBQUERY IN THE FROM CLAUSE
ORDER BY PROD_NUM; 

-- Analytic Function 

SELECT PROD_NUM
	, PROD_NAME
	, PROD_PRICE
	, CAST(AVG(PROD_PRICE) OVER (PARTITION BY VEND_ID) AS DECIMAL(10,2)) AS AVGPRICE -- This contains the analytic function syntax 
	, VEND_ID
FROM PRODUCT
ORDER BY PROD_NUM; 

-- ANALYTIC(attribute) OVER (PARTITION BY... ORDER BY... WINDOW ...) 
--		PARTITION BY operates like a GROUP BY clause for only the column
--		ORDER BY orders the returned values
--		WINDOW 

SELECT PROD_NUM
	, PROD_NAME
	, VEND_NAME
	, COUNT(*) OVER (PARTITION BY VEND_ID) AS NUMPRODUCTS
FROM VENDOR V JOIN PRODUCT P ON V.VEND_NUM = P.VEND_ID
ORDER BY PROD_NUM; 

-- Ranking Data

SELECT CUST_CODE
	, CUST_LNAME
	, CUST_BALANCE
	, CUST_STATE
	, RANK() OVER (PARTITION BY CUST_STATE ORDER BY CUST_BALANCE) AS "BALANCE RANKING" -- Rank must have an order by in order to function 
	, COUNT(*) OVER(PARTITION BY CUST_STATE) AS "NUMBER IN STATE"
FROM CUSTOMER; 

-- YOU CANNOT PUT AN ANALYTIC IN THE WHERE CLAUSE

SELECT * 
FROM (
	SELECT CUST_CODE
	, CUST_LNAME
	, CUST_BALANCE
	, CUST_STATE
	, RANK() OVER (PARTITION BY CUST_STATE ORDER BY CUST_BALANCE) AS "BALANCE RANKING" -- Rank must have an order by in order to function 
	, COUNT(*) OVER(PARTITION BY CUST_STATE) AS "NUMBER IN STATE"
	FROM CUSTOMER) AS RANKTABLE
WHERE "BALANCE RANKING" <= 3
ORDER BY CUST_STATE, "BALANCE RANKING", CUST_LNAME; 

-- WINDOWING CLAUSE

SELECT CUST_CODE
	, LEDGER_NUM
	, LEDGER_DATE
	, LEDGER_AMT
	, SUM(LEDGER_AMT) OVER (PARTITION BY CUST_CODE ORDER BY LEDGER_DATE) AS RUNNING -- This is windowing a running total for each row
FROM LEDGER
WHERE LEDGER_TRANSTYPE = 'P'
ORDER BY CUST_CODE, LEDGER_DATE; 


SELECT CUST_CODE
	, LEDGER_NUM
	, LEDGER_DATE
	, LEDGER_AMT
	, SUM(LEDGER_AMT) OVER (PARTITION BY CUST_CODE ORDER BY LEDGER_DATE ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS RUNNING -- This is windowing a specific window
FROM LEDGER
WHERE LEDGER_TRANSTYPE = 'P'
ORDER BY CUST_CODE, LEDGER_DATE; 

SELECT CUST_CODE
	, LEDGER_NUM
	, LEDGER_DATE
	, LEDGER_AMT
	, SUM(LEDGER_AMT) OVER (PARTITION BY CUST_CODE ORDER BY LEDGER_DATE ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS RUNNING -- This is windowing a specific window. It is now a last two payments total, no longer a "running" total
FROM LEDGER
WHERE LEDGER_TRANSTYPE = 'P'
ORDER BY CUST_CODE, LEDGER_DATE; 

SELECT CUST_CODE
	, LEDGER_NUM
	, LEDGER_DATE
	, LEDGER_AMT
	, SUM(LEDGER_AMT) OVER (PARTITION BY CUST_CODE ORDER BY LEDGER_DATE ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS RUNNING -- This is windowing a specific window. It is now a "descending" total
FROM LEDGER
WHERE LEDGER_TRANSTYPE = 'P'
ORDER BY CUST_CODE, LEDGER_DATE; 

-- Doing calcs within a row is easy, but doing lag and lead functions that calculate previous and upcoming rows. 

SELECT EMP_NUM
	, EMP_LNAME
	, EMP_TITLE
	, EMP_HIREDATE
	, EMP_SALARY
	, LAG(EMP_SALARY, 1, 0) OVER (PARTITION BY EMP_TITLE ORDER BY EMP_HIREDATE) AS PREVIOUS
	, EMP_SALARY - LAG(EMP_SALARY, 1, 0) OVER (PARTITION BY EMP_TITLE ORDER BY EMP_HIREDATE) AS DIFFERENCE
FROM EMPLOYEE; 

SELECT EMP_NUM
	, EMP_LNAME
	, EMP_TITLE
	, EMP_HIREDATE
	, EMP_SALARY
	, LEAD(EMP_SALARY, 1, 0) OVER (PARTITION BY EMP_TITLE ORDER BY EMP_HIREDATE) AS NEXTHIRE
	-- , EMP_SALARY - LAG(EMP_SALARY, 1, 0) OVER (PARTITION BY EMP_TITLE ORDER BY EMP_HIREDATE) AS DIFFERENCE
FROM EMPLOYEE; 
