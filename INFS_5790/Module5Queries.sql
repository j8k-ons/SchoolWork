/* SELECT query
   SELECT clause */

/* SELECT introduction */

SELECT * 
FROM PRODUCT; 

/* SELECT specific Columns */

SELECT P_CODE, P_DESCRIPT, V_CODE, P_PRICE
FROM PRODUCT; 

/* SELECT column alias */

SELECT P_CODE AS CODE, P_DESCRIPT AS "PRODUCT DESCRIPTION", P_PRICE AS Price
FROM PRODUCT; 

/* SELECT Distinct Values */

SELECT DISTINCT V_CODE 
FROM PRODUCT; 

/* Derived Attributes */

SELECT P_PRICE * P_QOH AS "LINE TOTAL"
FROM PRODUCT; 

/* SELECT Concatenation 
	NEVER USE: 
	-- CONCATENATE TWO LITERALS
	-- USE + FOR CONCATENATION
*/

SELECT CUS_CODE, CONCAT(CUS_FNAME,' ',CUS_LNAME) AS "Name" 
FROM CUSTOMER; 

SELECT CUS_CODE, CONCAT(CUS_FNAME,' ', CUS_LNAME) AS "Name", CONCAT('(', CUS_AREACODE, ') ', CUS_PHONE) AS PHONE
FROM CUSTOMER; 

/* SELECT Rounding */

SELECT P_CODE, P_DESCRIPT, ROUND(P_PRICE, 0) 
FROM PRODUCT; 

/* SELECT Format Currency */

SELECT CUS_CODE, CUS_LNAME, CUS_BALANCE, FORMAT(CUS_BALANCE/12, 'C')
FROM CUSTOMER; 

/* Format Dates */
/*-- Capitalization Matters 
  -- DBMS no longer considers it a date once it is formatted
*/
SELECT P_CODE, P_DESCRIPT, P_INDATE, FORMAT(P_INDATE, 'MMMM dd, yyyy') AS "Formatted Date"
FROM PRODUCT; 

/* SELECT Date Addition */
SELECT P_CODE, P_DESCRIPT, P_INDATE, DATEADD(YEAR,3,P_INDATE) AS "3 Years Later"
FROM PRODUCT; 

/* SELECT Date Intervals */
SELECT P_CODE, DATEDIFF(DAY, P_INDATE, GETDATE())
FROM PRODUCT; 

/* INNER JOIN 2 TABLES */
SELECT * 
FROM PRODUCT JOIN VENDOR ON PRODUCT.V_CODE = VENDOR.V_CODE

/* Table Alias */
/* Alias used for a table for a single query. Some require AS, some do not allow the AS, */
SELECT V.V_CODE, P_CODE, P_DESCRIPT, V_NAME
FROM PRODUCT P JOIN VENDOR AS V ON P.V_CODE = V.V_CODE; 

/* INNER JOIN MORE THAN 2 TABLES */ 
SELECT * 
FROM CUSTOMER JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
	JOIN LINE ON INVOICE.INV_NUMBER = LINE.INV_NUMBER
	JOIN PRODUCT ON PRODUCT.P_CODE = LINE.P_CODE
	JOIN VENDOR ON VENDOR.V_CODE = PRODUCT.V_CODE

/* OUTER JOINS with 2 TABLES */
/* LEFT */
SELECT * 
FROM PRODUCT LEFT JOIN VENDOR ON PRODUCT.V_CODE = VENDOR.V_CODE

/* RIGHT */
SELECT * 
FROM PRODUCT RIGHT JOIN VENDOR ON PRODUCT.V_CODE = VENDOR.V_CODE

/* OUTER JOINS with more than 2 TABLES */
SELECT * 
FROM CUSTOMER LEFT JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
	LEFT JOIN LINE ON LINE.INV_NUMBER = INVOICE.INV_NUMBER
	LEFT JOIN PRODUCT ON PRODUCT.P_CODE = LINE.P_CODE

-- EMBEDDED SQL PRACTICE 1
/* PROBLEM 1 */
SELECT CUSTOMER.CUS_FNAME AS "First Name" 
	   , CUSTOMER.CUS_LNAME AS "Last Name" 
	   , CUSTOMER.CUS_BALANCE AS "Balance" 
FROM CUSTOMER; 
	

/* PROBLEM 2 */
SELECT INV_NUMBER AS "INVOICE"
	   , LINE_NUMBER AS "LINE"
	   , P_CODE AS PRODUCT
	   , LINE_PRICE * LINE_UNITS AS "LINE TOTAL"
FROM LINE

/* PROBLEM 3 */
SELECT DISTINCT VENDOR.V_STATE
FROM VENDOR

/* Ordering Ascending or Descending */

-- NUMERIC: LOW to HIGH
SELECT * 
FROM PRODUCT 
ORDER BY P_PRICE; 

-- ALPHANUMERIC: NULL -> # -> A - Z in SQL SERVER , # -> A-Z -> NULL in ORACLE 
SELECT * 
FROM PRODUCT 
ORDER BY P_DESCRIPT; 

-- DESC Reverses these 

/* ORDERING BY MORE THAN 1 COLUMN */ 
-- SORT BY VENDOR, AND WITHIN VENDORS SORT BY PRICE, IF PRICES MATCH SORT BY PRODUCT CODE
SELECT *
FROM PRODUCT 
ORDER BY V_CODE DESC, P_PRICE, P_CODE; 

/* ORDERING BY FORMATTED DATES AND NUMBERS */
-- DATES are NUMBERS SO LOW TO HIGH
SELECT P_CODE, P_DESCRIPT, FORMAT(P_INDATE, 'MM/dd/yyyy') AS NEWDATE, FORMAT(P_PRICE, 'C') AS NEWPRICE
FROM PRODUCT
ORDER BY P_PRICE; 

/* WHERE CLAUSE BASIC OPTIONS */
SELECT * 
FROM PRODUCT
WHERE P_PRICE > 100; 

SELECT * 
FROM PRODUCT 
WHERE P_DISCOUNT <> 0; 

SELECT * 
FROM PRODUCT
WHERE P_PRICE > 100 AND P_DISCOUNT != 0; 

SELECT * 
FROM PRODUCT
WHERE (V_CODE = 24288 OR V_CODE = 25595) AND P_PRICE > 100; 

/* SPECIAL OPERATORS */

-- BETWEEN

SELECT P_CODE, P_DESCRIPT, P_PRICE, P_QOH
FROM PRODUCT
WHERE P_PRICE BETWEEN 10 AND 20; 

SELECT P_CODE, P_DESCRIPT, P_INDATE
FROM PRODUCT
WHERE P_INDATE BETWEEN '01-JAN-21' AND '15-JAN-22'; 

-- IN OPERATOR

SELECT V_CODE, V_NAME, V_STATE
FROM VENDOR
WHERE V_STATE IN ('TN','KY','GA'); 

-- LIKE 
-- ALLOW SUBSTRING SEARCH

SELECT P_CODE, P_DESCRIPT, P_PRICE 
FROM PRODUCT
WHERE P_DESCRIPT LIKE '%SAW%'; 

-- IS NULL
-- FIND ATTRIBUTES WHERE THERE IS A NULL VALUE

SELECT * 
FROM PRODUCT
WHERE V_CODE IS NULL; 

/* NEGATION OF SPECIAL OPERATORS */

-- NOT

SELECT * 
FROM PRODUCT
WHERE P_QOH NOT BETWEEN 15 AND 25; 

SELECT * 
FROM PRODUCT
WHERE V_CODE NOT IN (25595, 21344); 

SELECT * 
FROM PRODUCT
WHERE P_DESCRIPT NOT LIKE '%saw%'; 

SELECT * 
FROM PRODUCT
WHERE V_CODE IS NOT NULL; 

-- OTHER 

SELECT UPPER(P_CODE), P_DESCRIPT
FROM PRODUCT
WHERE LOWER(P_CODE) = '11qer/31'; 

/* SQL Practice 2 */

-- PROBLEM 4

SELECT CONCAT(P_DESCRIPT,' (' ,P_CODE,')') AS PRODUCT, P_PRICE, P_INDATE
FROM PRODUCT

-- PROBLEM 5

SELECT INV_NUMBER
	, INV_DATE AS 'Purchase Date'
	, DATEADD(DAY, 45, INV_DATE)  AS 'Payment Date'
FROM INVOICE; 

-- PROBLEM 6
SELECT CONCAT(C.CUS_FNAME, ' ', C.CUS_LNAME) AS Customer, INVOICE.INV_NUMBER AS 'Invoice', INVOICE.INV_DATE AS 'Purchase Date'
FROM CUSTOMER C
JOIN INVOICE ON C.CUS_CODE = INVOICE.CUS_CODE

-- PROBLEM 7

SELECT DISTINCT CUS_FNAME, CUS_LNAME, CUS_BALANCE
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE

-- PROBLEM 8

SELECT CUSTOMER.CUS_FNAME, CUSTOMER.CUS_LNAME, CUSTOMER.CUS_BALANCE, INVOICE.INV_DATE, LINE.P_CODE
FROM CUSTOMER
LEFT JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
LEFT JOIN LINE ON LINE.INV_NUMBER = INVOICE.INV_NUMBER
ORDER BY CUSTOMER.CUS_LNAME, CUSTOMER.CUS_FNAME, INVOICE.INV_DATE, LINE.P_CODE

/* Embedded SQL Practice 3 */

-- Problem 9

SELECT PRODUCT.P_CODE
	, PRODUCT.P_DESCRIPT AS "DESCRIPTION"
	, PRODUCT.P_DISCOUNT AS "DISCOUNT"
	, INVOICE.INV_NUMBER
	, LINE.LINE_NUMBER
	, LINE.LINE_PRICE * LINE.LINE_UNITS AS "LINE TOTAL"
FROM PRODUCT
LEFT JOIN LINE ON PRODUCT.P_CODE = LINE.P_CODE
LEFT JOIN INVOICE ON LINE.INV_NUMBER = INVOICE.INV_NUMBER 
WHERE PRODUCT.P_DISCOUNT = 0
ORDER BY "LINE TOTAL"	

-- Problem 10

SELECT VENDOR.V_CODE
	, VENDOR.V_NAME
	, PRODUCT.P_DESCRIPT
	, PRODUCT.P_PRICE
	, PRODUCT.P_QOH
FROM VENDOR
JOIN PRODUCT ON PRODUCT.V_CODE = VENDOR.V_CODE
WHERE VENDOR.V_STATE IN ('TN','FL') AND PRODUCT.P_PRICE >= 100
ORDER BY P_PRICE DESC; 

-- Problem 11

SELECT CUSTOMER.CUS_CODE
	, CONCAT(CUSTOMER.CUS_LNAME,',',CUSTOMER.CUS_FNAME,' ', CUSTOMER.CUS_INITIAL) AS CUSTOMER
	, CUSTOMER.CUS_BALANCE, INVOICE.INV_DATE AS Purchased
	, PRODUCT.P_CODE
	, CONCAT('$',LINE.LINE_PRICE * LINE.LINE_UNITS) AS "Line Total"
	, CONCAT(ROUND(((LINE.LINE_PRICE * LINE.LINE_UNITS)/(Customer.CUS_BALANCE)) * 100,2),'%') AS "Percent of Balance"
FROM CUSTOMER
JOIN INVOICE ON INVOICE.CUS_CODE = CUSTOMER.CUS_CODE
JOIN LINE ON LINE.INV_NUMBER = INVOICE.INV_NUMBER
JOIN PRODUCT ON PRODUCT.P_CODE = LINE.P_CODE
WHERE CUSTOMER.CUS_BALANCE > 0
ORDER BY [Percent of Balance] DESC; 

/* Aggregate Functions 
-- Work across a range of values then aggregate to a single value
-- COUNT
-- SUM
-- AVG
-- MAX
-- MIN
*/

SELECT AVG(CUS_BALANCE) As "AVG Balance"
FROM CUSTOMER

-- Aggregate with Groups
-- Not all rows have to be summed 

SELECT ROUND(AVG(CUS_BALANCE),2) AS "AVG BALANCE"
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
WHERE CUS_AREACODE = 615

-- Or treat them as multiple selections

SELECT LINE.INV_NUMBER, INV_DATE, SUM(LINE_UNITS * LINE_PRICE) AS "INVOICE TOTAL"
FROM LINE
JOIN INVOICE on LINE.INV_NUMBER = INVOICE.INV_NUMBER
GROUP BY LINE.INV_NUMBER, INV_DATE;

-- You must include non aggregated values in the group by clause
SELECT INV_NUMBER, P_CODE, SUM(LINE_UNITS * LINE_PRICE) AS "INVOICE TOTAL"
FROM LINE
GROUP BY INV_NUMBER, P_CODE
ORDER BY INV_NUMBER; 


-- HAVING CLAUSE
-- WHICH GROUPS WILL BE RETURNED BY THE QUERY
-- WHERE CLAUSE WILL CAUSE AN ERROR B/C WHERE RUNS BEFORE GROUP BY
SELECT INV_NUMBER, SUM(LINE_UNITS * LINE_PRICE) AS "INVOICE TOTAL"
FROM LINE
GROUP BY INV_NUMBER
HAVING SUM(LINE_UNITS * LINE_PRICE) > 35
ORDER BY INV_NUMBER; 

-- Having clause does not have to have a value in the select clause
-- Returns groups with more than 1 row 
SELECT INV_NUMBER, SUM(LINE_UNITS * LINE_PRICE) AS "INVOICE TOTAL"
FROM LINE
GROUP BY INV_NUMBER
HAVING COUNT(*) > 1
ORDER BY INV_NUMBER; 

SELECT V_CODE, AVG(P_PRICE) AS AVGPRICE
FROM PRODUCT
WHERE P_QOH > 10
GROUP BY V_CODE
HAVING COUNT(*) > 1
ORDER BY AVGPRICE; 

-- Aggregates of Aggregates

SELECT MAX(AVGPRICE) AS "LARGEST AVERAGE"
FROM (SELECT V_CODE, AVG(P_PRICE) AS AVGPRICE
	FROM PRODUCT
	GROUP BY V_CODE) AS AVGTABLE

/* Embedded SQL Practice 4 */

-- Problem 12
-- Using 1 is more efficient because there is no trip to the data dictionary since we are only getting a count of the rows that are returned. 
SELECT COUNT(1) AS "Customer(s) with No Balance"
FROM CUSTOMER
WHERE CUSTOMER.CUS_BALANCE = 0; 

-- Problem 13

SELECT FORMAT(MAX(CUS_BALANCE), 'C') AS "Largest Balance"
	, FORMAT(AVG(CUS_BALANCE), 'C') AS "Average Balance"
FROM CUSTOMER

-- Problem 14

SELECT COUNT(DISTINCT CUSTOMER.CUS_CODE) as 'Customers'
FROM CUSTOMER 
JOIN INVOICE ON INVOICE.CUS_CODE = CUSTOMER.CUS_CODE

-- Problem 15

SELECT CUSTOMER.CUS_CODE, CUS_LNAME, COUNT(INVOICE.INV_NUMBER) AS "NUMINVOICES"
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
GROUP BY CUSTOMER.CUS_CODE, CUS_LNAME
ORDER BY CUS_CODE

-- Problem 16

SELECT CUSTOMER.CUS_CODE, CUS_LNAME, COUNT(INVOICE.INV_NUMBER) AS "NUMINVOICES", CUSTOMER.CUS_BALANCE AS "BALANCE"
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
GROUP BY CUSTOMER.CUS_CODE, CUS_LNAME, CUS_BALANCE
ORDER BY CUS_CODE

/* Uncorrelated Subquery in FORM 
   Combining aggregate data and individual row data without grouping by individual row data */

SELECT cuspurchases.cus_code, cus_lname, "Total Purchase", inv_number, inv_date
FROM (
SELECT	CUSTOMER.CUS_CODE, CUS_LNAME, sum(line_units * line_price) as "Total Purchase"
FROM CUSTOMER 
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
JOIN LINE ON INVOICE.INV_NUMBER = line.INV_NUMBER
GROUP BY CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME) AS CusPurchases
JOIN INVOICE ON CusPurchases.CUS_CODE = INVOICE.CUS_CODE
ORDER BY CusPurchases.CUS_CODE

-- Uncorreclated Subquery in WHERE
-- Preproccesses data before a comparison

-- DO not use GROUP BY unless the query is RETURNING an aggregate

SELECT P_CODE, P_DESCRIPT, P_PRICE
FROM PRODUCT
WHERE P_PRICE > AVG(P_PRICE); -- This will error out due to having an aggregate in a where clause

SELECT P_CODE, P_DESCRIPT, P_PRICE
FROM PRODUCT
WHERE P_PRICE > (SELECT AVG(P_PRICE) FROM PRODUCT);

SELECT P_CODE, P_DESCRIPT, V_CODE
FROM PRODUCT
WHERE V_CODE IN (SELECT V_CODE FROM VENDOR WHERE V_STATE = 'TN'); 

-- Evil Cartesian Products

SELECT * 
FROM PRODUCT, VENDOR; -- Pairing every product with every vendor, which is wrong. 

-- Find Unmatched Rows
SELECT * 
FROM PRODUCT
WHERE V_CODE IS NULL; 

-- Using a Join
SELECT * 
FROM PRODUCT 
RIGHT JOIN VENDOR ON PRODUCT.V_CODE = VENDOR.V_CODE
WHERE P_CODE IS NULL; 

-- Using a subquery
SELECT * 
FROM VENDOR 
WHERE V_CODE NOT IN 
(SELECT V_CODE
FROM PRODUCT WHERE V_CODE IS NOT NULL); 

/* Embedded SQL Practice 5 */

-- Problem 17

SELECT CUSTOMER.CUS_CODE
	, CUSTOMER.CUS_LNAME
	, COUNT(DISTINCT INVOICE.INV_NUMBER) AS NUMINVOICES
	, COUNT(DISTINCT LINE.P_CODE) AS NUMPRODUCTS
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
JOIN LINE ON INVOICE.INV_NUMBER = LINE.INV_NUMBER
GROUP BY CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME
ORDER BY CUS_CODE; 


-- Problem 18

SELECT DISTINCT CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME, COUNT(DISTINCT INVOICE.INV_NUMBER), LINE.P_CODE
FROM CUSTOMER
JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
JOIN LINE ON INVOICE.INV_NUMBER = LINE.INV_NUMBER
GROUP BY CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME, LINE.P_CODE -- This is the problem here
ORDER BY CUSTOMER.CUS_CODE

SELECT DISTINCT INVOICECOUNT.CUS_CODE, INVOICECOUNT.CUS_LNAME, INVOICECOUNT.NUMINVOICES, LINE.P_CODE
FROM (SELECT CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME, COUNT(INVOICE.INV_NUMBER) AS NUMINVOICES
		FROM CUSTOMER 
		JOIN INVOICE ON CUSTOMER.CUS_CODE = INVOICE.CUS_CODE
		GROUP BY CUSTOMER.CUS_CODE, CUSTOMER.CUS_LNAME) AS INVOICECOUNT
		JOIN INVOICE ON INVOICECOUNT.CUS_CODE = INVOICE.CUS_CODE
		JOIN LINE ON INVOICE.INV_NUMBER = LINE.INV_NUMBER
		ORDER BY INVOICECOUNT.CUS_CODE, LINE.P_CODE
